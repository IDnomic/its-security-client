# README

# Using scoop/dist-client

## 1. Introduction:

The client code models a PKI client example (namely ITS_S) for ISE/Scoop@F project, requesting and receiving certificates: an EC (enroll credential) or an AT (authorization ticket). The code is written in C.

## 2. Requirements:

### The following options are required before running the client:
* OpenSSL: version > 1.0.2
* EA (Enrolment Authority) options: IP address, HashedId8, Public verification key, Public encryption key.
* AA (Authorization Authority) options: IP address, HashedId8, Public verification key, Public encryption key.
* ITS_S (ITS Station) options: Profile AID/SSP list in Hex format (ex: 240301E500), ID, ITS_S technical private key of type: ECC on curve prime256v1.

### Configuration of ITS_S:

* ITS_S keys (technical, enrollement, authorization, response_decryption_key) can be generated by the client.
* ITS_S Technical public key, ID (its canonical name) and AID/SSP must be registered by the operator.

## 3. Quick start using existing shell scripts:

Some examples of shell scripts are present in this package to simulate the communication between ITS_S, EA and AA.

Before executing any of the following shell scripts, shells parameters must be verified according to the corresponding options defined in the latter section.
* `./prepareITS.sh`
    * generates ITS_S Technical private key.
* `./getpubkeyforitsregistration.sh TechnicalKey` (with argument the technical ITS_S private key)
    * obtain ITS_S Technical public key.
* `./enrollEC.sh`
    * Request a certificate enrollment for ITS_S.
* `./enrollAT.sh` (After EC enrollment)
    * Request an autorization ticket for ITS_S.

## 4. Compilation:

Use command `make` in a unix environnement.

## 5. Functions:

The main application for running the client is implemented in PKIClient.c, it can be executed using the following command:

`./PKIClient "function_name" --"arguments1" --"argument2" ... `

### a) Functions architecture:

* Each Function is constructed by 6 methods:
	* printhelp : print the arguments options for the corresponding function.
	* init : take input arguments and initialise the variables.
	* verifyargs : verify entered arguments.
	* gen : All computation is done in this function, and in its final step generates the output DER file.
	* main : main application method.
	* cleanup : free variables from memory.


* Data input and output are encapsulated in 'DER' files; data structure is formed by the content type and the content.


* Signed data type includes the signer Hashed8ID and is signed with signer private key.


* Encrypted data type is obtained as follow:
	* Generate an AES key and an AES nonce.
	* Encrypt the data with AES and build the encrypted data type.
	* Add the AES key to the data, and encrypt by recipient public key.

### b) Functions description:

#### `genkey`: generates an asymmetric elliptic private key ECprime256.

* Arguments:
	* `-o , --output <file_name>`	Choose the output file
	* `-c , --compressed`	Compressed key
	* `-e , --explicitcurve`	Use explicit EC curve
* computation steps:

	  Generates the private key using Openssl library to the output file.


#### `genECEnroll`: generates the EC enroll request (described in ./enrollEC.sh).

* Arguments:
	* `-i , --canonicalid <value>` 	 ID of the ITS_S (its canonical name)
	* `-d , --responsedecryptionkey <file_name>` 	 private key used to decrypt the response from the EA
	* `-v , --verificationkey <file_name>` 	 ITS_S verification private key to be enrolled
	* `-p , --itsaidssplist <hex value>` 	 ITS_S profile AID/SSP list in hex
	* `-e , --encryptionkey <file_name>` 	 ITS_S encryption private key to be enrolled [optional]
	* `-r , --validityrestrictions <hex value>` 	 geographic or temporal restrictions [optional]
	* `-o , --output <file_name>`  	 the file name for the output data
	* `-k , --technicalkey <file_name>` 	 input the signer Technical private key
	* `-R , --eaid <8 bytes hex value>` 	 input the hashedID8 of EA public certificate
	* `-K , --eakey <file_name>` 	 input EA encryption public key
	* `-t , --taiutc <value>` 	 difference between TAI and UTC time.
* computation steps:
	1. Creating ASN1 object for ITS_S profile AID/SSP list
	2. Create ASN1 object for the verification public key (from the private key input)
	3. Create ASN1 object for the encryption public key (from the private key input)
	4. Build the Inner EC Request object from the 3 later objects + the response decryption private key
	5. Sign the Inner EC Request with ITS_S Technical private key
	6. Generate AES Key, Encrypt the signed data with AES
	7. Add the AES key to the encrypted data, and EA HashedID8 and encrypt with EA public key
	8. encapsulate the data in DER file and output this file


#### `receiveECResponse`: receive the EC enroll (described in `./enrollEC.sh`).
* Arguments:
	* `-i , --input <file_name>` 	the DER file name received from the EA
	* `-o , --output <file_name>`	 the file name for the output data
	* `-k , --responsedecryptionkey <file_name>`	 private key used to encrypt the response of the EA
	* `-v , --eaverificationkey <file_name>`	 EA public key for verification
	* `-e , --eaid <8 bytes hex value>`	 input the hashedID8 of EA public certificate
	* `-r , --request <file_name> `	 the DER file sent for enrollment request [optional]
* computation steps:
	1. check data version and if content exists
	2. the response can contain: - signed data with negative response, encryption of signed data with negative response, and encryption of signed data with positive response.
	3. if data is encrypted: decode and decrypt with response decryption key, then data must be a signed inner EC response type, verify the signature, and decode the data to obtain the inner response.
	4. if data is signed: data type must be an EC Inner response, decode and verify the signature.
	5. read the Inner response and output the returned certificate, EA answer (negative or positive) or errors.


#### `genATEnroll`: generates the shared AT request (described in ./enrollAT.sh).

* Arguments:
	* `-k , --signaturekey <file_name>` 	 ITS_S enrolled private key
	* `-d , --responsedecryptionkey <file_name>` 	 private key used to encrypt the response of the AA
	* `-v , --verificationkey <file_name>` 	 ITS_S verification private key to be given authorization
	* `-e , --encryptionkey <file_name>` 	 ITS_S encryption private key to be given authorization
	* `-p , --itsaidssplist <hex value>` 	  ITS_S profile AID/SSP list in hex
	* `-r , --validityrestrictions <hex value>` 	 Geographic or temporal restrictions [optional]
	* `-R , --eaid <8 bytes hex value>` 	 input the hashedID8 of EA public certificate
	* `-K , --eaencryptionkey <file_name>` 	 EA public key for encryption
	* `-a , --aaid <8 bytes hex value>` 	 input the hashedID8 of AA public certificate
	* `-A , --aaencryptionkey <file_name>` 	 AA public key for encryption
	* `-o , --output <file_name>` 	 the file name for the output data
	* `-s , --start <integer>` 	 Choose a desired start date and time [optional]
	* `-t , --taiutc <value>` 	 Difference between TAI and UTC time
	* `-c , --enrolmentcertificate <file_name>` 	 ITS_S enrolled certificate
* computation steps:
	1. Generate an HMAC KEY
	2. Calculate an HMAC tag on the encoded verification and encryption keys
	3. Build shared AT request from calculated tag and input objects: eaid, responsedecryptionkey, validityrestrictions, start, and subjectattributes.
	4. sign the shared AT request with enrollment private key, detached signature.
	5  Generate an AES key and encrypt the signed data for the EA with EA public key
	6. build the inner AT request = shared AT request + verificationkey + encryptionkey + hmac key +encrypted signed data
	7. Generate another AES key and encrypt all data for the AA with AA public key
	8. encapsulate in a DER file


#### `receiveATResponse`: receive the AT (described in `./enrollAT.sh`).
* Arguments:
	* `-i , --input <file_name>`	 the DER file name received from the AA
	* `-o , --output <file_name>`	 the file name for the output data
	* `-k , --responsedecryptionkey <file_name>` 	 private key used to encrypt the response of the AA
	* `-v , --eaverificationkey <file_name>` 	 AA public key for verification
	* `-e , --eaid <8 bytes hex value>` 	 input the hashedID8 of AA public certificate
	*` -r , --request <file_name>` 	 the DER file sent for authorization request [optional]
* computation steps:
	1. check data version and if content exists
	2. the response can contain: - signed data with negative response, encryption of signed data with negative response, and encryption of signed data with positive response.
	3. if data is encrypted: decode and decrypt with response decryption key, then data must be a signed inner AT response type, verify the signature, and decode the data to obtain the inner response.
	4. if data is signed: data type must be an AT Inner response, decode and verify the signature.
	5. read the Inner response and output the returned certificate, AA answer (negative or positive) or errors.


N.B: Any function can take arguments: `--help` and `--debug`.

### c) Libraries and corresponding methods:

*   `utils`: `ETSI_ECIES_KDF`, `decryptccm`, `dump`, `encodeasIntX`, `encryptccm`, `getHashedId8`, `hashthis`, `hextobin`, `pushbuf`, `readECPrivateKey`, `readECPublicKey`, `readfile`, `unhex`, `writeECPrivateKey`, `writefile`.


*   `ise_asn1`: `ISE_PUBLICKEY_SET`, `ISE_PUBLICKEY_to_EC_KEY`, `addISEoids`.


*   `isetoolbox`: `ASN1_OBJECT_cmp`, `ISE_PUBLICKEY_HashedId8`, `STACK_OF`, `addEncryptedDataRecipient`, `buildData`, `buildEncryptedData`, `buildInnerATRequest`, `buildInnerECRequest`, `buildSharedATRequest`, `buildSignedData`, `decryptECIES`, `decrypt_ISE_ENCRYPTEDDATA`, `encryptECIES`, `genSecretAESCCMParameters`, `signSignedData`, `verifySignatureData`, `verifySignerInfoSignature`.


* OpenSSL library.
